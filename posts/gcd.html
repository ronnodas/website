<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="description" content="Homepage of Ronno Das">
    <meta name="author" content="Ronno Das">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans%7CUbuntu&display=swap" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="posts.css" media="screen">
    <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://unpkg.com/@highlightjs/cdn-assets@11.9.0/highlight.min.js"></script>
    <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
    <script>hljs.addPlugin(new CopyButtonPlugin()); hljs.highlightAll();</script>
    <title>Extended Euclidean algorithm for non-negative integers</title>
</head>

<body>
    <div class="main">
        <div class="scroll">
            <h2>Extended Euclidean algorithm for non-negative integers <span class="date">2022-08-29</span></h2>

            <p>tl;dr: here's a Rust function (<a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=8cc753cf2b9c8f84bfbd7ef5a54b8871">playground link</a>) that performs the &quot;extended Euclidean algorithm&quot;.</p>
<pre><code class="language-rust">fn extended_gcd(a: usize, b: usize) -&gt; (usize, usize, usize) {
    let remainder = a % b;
    if remainder == 0 {
        return (b, 0, if a == b {0} else {1});
    }
    let quotient = a / b;
    let (gcd, x, y) = extended_gcd(b, remainder);
    let new_y =  (((b * x + remainder - gcd) / remainder) * quotient + x + a - quotient) % a;     // what in the 0x5F3759DF?
    (gcd, y, new_y)
}
</code></pre>
<p>It assumes <code>a &gt;= 0, b &gt; 0</code> (divides by <code>b</code> and so crashes if <code>b == 0</code>) and outputs <code>(d, x, y)</code> such that:</p>
<ul>
<li>\(d = \gcd(a, b)\);</li>
<li>\(0 \le x &lt; b/d\) and \(0 \le y &lt; a/d\) (if \(a &gt; 0\), otherwise \(y = 0\));</li>
<li>\(ax + by \equiv d \pmod{\operatorname{lcm}(a, b)}\).</li>
</ul>
<p>It will also not underflow, but might overflow if <code>a</code> or <code>b</code> is too big. It uses <code>usize</code> as the type as an example, but it will work with any unsigned integer type, in particular big integer types that support the required arithmetic operations. It would not be so much harder to avoid recursive calls (or to handle the case \(b = 0\) once you decide what the output there should be) but I think it's tricky enough already.</p>
<p>This code is in Rust because that's the only language with a built-in unsigned integer type that I'm comfortable using. If you want to port it to another language, keep in mind <a href="https://en.wikipedia.org/wiki/Modulo">the conventions of how <code>/</code> and <code>%</code> work</a>. For reference, the function as written assumes that the quotient is rounded towards \(0\), so <code>a/b</code> is \(\lfloor a/b \rfloor\) and <code>a % b</code> satisfies <code>a = (a / b) * b + (a % b)</code>.</p>
<p>The rest of this post is about why this <em>should</em> be called the <em>extended Euclidean algorithm</em>.</p>
<h3>Abstract(?) algebra</h3>
<p>Let's talk about gcds. Given \(a, b \in \mathbf{Z}\), not both \(0\), there are a few possible definitions of \(\gcd(a, b)\):</p>
<ol>
<li>\(\gcd(a, b)\) is the largest among the common divisors of \(a\) and \(b\).</li>
<li>\(\gcd(a, b)\) is the <em>smallest</em> positive integer that can be written in the form \(ax + by\) with \(x, y \in \mathbf{Z}\).</li>
<li>\(\gcd(a, b)\) is the unique non-negative generator of the subgroup/ideal \(a\mathbf{Z} + b\mathbf{Z}\) of \(\mathbf{Z}\).</li>
<li>\(\gcd(a, b)\) is what the Euclidean algorithm returns when started with the arguments \(a\) and \(b\).</li>
</ol>
<p>If we relax the meaning of largest and smallest, these definitions are leveraging increasing amounts of &quot;niceness&quot; for the ring of integers:</p>
<ul>
<li>\(\mathbf{Z}\) is a unique factorization domain, so up to units has meets (and joins) as a poset under divisors.</li>
<li>\(\mathbf{Z}\) is a Bezout domain, ie the meet \(a \land b\) can be written as a linear combination of \(a\) and \(b\).</li>
<li>\(\mathbf{Z}\) is a principal ideal domain, so the ideal \(a\mathbf{Z} + b\mathbf{Z}\) is generated by a single element.</li>
<li>\(\mathbf{Z}\) is a Euclidean domain, ie has a well-defined sense of division with <em>smaller</em> remainder, and hence is a domain for running the Euclidean algorithm.</li>
</ul>
<p>You might notice that definitions 2 and 3 are very close to each other, in fact they are generally equivalent: a finitely generated ideal in a Bezout domain must be principal. (Therefore a Bezout domain that is not a PID has to be non-Noetherian. The most reasonable example seems to be the ring of algebraic integers, see eg <a href="https://math.stackexchange.com/questions/1302481/how-to-prove-that-the-ring-of-all-algebraic-integers-is-a-b%C3%A9zout-domain">this math.stackexchange question</a>.)</p>
<p>Given definition 4, it seems a pertinent question how &quot;computable&quot; the other definitions are. A reasonable interpretation of this for definition 1 is to exhibit the entire set of common divisors of \(a\) and \(b\), ie find the factors of \(d = \gcd(a, b)\). This is <a href="https://en.wikipedia.org/wiki/Integer_factorization">believed to be hard</a>.</p>
<p>This brings us to the extended Euclidean algorithm, which given \(a, b \in \mathbf{Z}\), not both \(0\), computes \(x, y \in \mathbf{Z}\) such that \(ax + by = \gcd(a, b)\). This is not much more than the usual Euclidean algorithm, you just keep track of the quotients. The key point is that if dividing \(a\) by \(b\) gives quotient \(q\) and remainder \(r\) then \(r = a - q b\), so we can recursively/inductively express the remainder at each step as an explicit linear combination of \(a\) and \(b\).</p>
<h3>Uniqueness</h3>
<p>How unique are these \(x\) and \(y\)? Not at all:
\(ax + by = a(x + nb) + b (y - na)\)
for each \(n \in \mathbf{Z}\), or in fact for \(n \in \frac{1}{d} \mathbf{Z}\). In fact that is exactly the amount of ambiguity, \(x\) can be changed to anything in the coset \(x + (b/d)\mathbf{Z}\) alongwith a corresponding change of \(y\) to something in \(y + (a/d)\mathbf{Z}\). Note that independent of these choices, \(ax\) and \(by\) take values in fixed cosets of \((ab/d)\mathbf{Z} = \operatorname{lcm}(a, b) \mathbf{Z}\) (and add to \(1 + (ab/d)\mathbf{Z}\)).</p>
<p>What about uniqueness of \(d = \gcd(a, b)\)? The generator of a principal ideal is only defined up to units. Similarly divisibility is unaffected by multiplication by units. So if we want the gcd to be unique, the sense of &quot;greatest&quot; has to involve the ordering of integers, and not just the divisibility order.</p>
<h3>Positive integers</h3>
<p>We can try to fix this by adopting the convention of identifying subgroups of \(\mathbf{Z}\) with their unique non-negative generator, and restricting our domain to \(\mathbf{N} = \mathbf{Z}_{\ge 0}\). Let's see how the definitions of \(\gcd\) are affected:</p>
<ol>
<li>\(\gcd(a, b)\) is still the largest among the common divisors of \(a\) and \(b\). Now \(\mathbf{N}\) is an actual poset with meets.</li>
<li>\(\gcd(a, b)\) in general cannot be written in the form \(ax + by\) with \(x, y \in \mathbf{N}\). The smallest positive integer of this form is \(\min(a, b)\) (unless one of \(a, b\) is \(0\), in which case it is the other one).</li>
<li>The submonoid/cone \(a\mathbf{N} + b\mathbf{N}\) of \(\mathbf{N}\) is not necessarily &quot;principal&quot; (ie generated by a single element) and is in general smaller than \(\mathbf{N} \cap (a\mathbf{Z} + b\mathbf{Z})\).</li>
<li>The Euclidean algorithm still works and still returns \(\gcd(a, b)\) when started with the arguments \(a\) and \(b\).</li>
</ol>
<p>The extended Euclidean algorithm no longer works, since \(a - bq\) is no longer a valid operation. So we seem to have broken things.</p>
<p>All hope is not lost. Remember that our goal was to compute the cosets \(x + (b/d)\mathbf{Z}\) and \(y + (a/d)\mathbf{Z}\), after replacing subgroups by their non-negative generators. In this description, what should we represent cosets by? The subgroup generated by \(0\) behaves differently, so let's ignore that. The cosets of \(n \in \mathbf{N}_{&gt; 0}\) (ie of \(n\mathbf{Z}\)) exactly correspond to elements in \([n] := \{0, \dots, n - 1\}\) (this choice is better than \(\{1, \dots, n\}\) since it corresponds to the usual convention of the operation \(a \mapsto a \mathop{\%} n = a \bmod n\)). So the question translates to, given \(a, b \in \mathbf{N}_{&gt; 0}\), finding \(d = \gcd(a, b)\), \(x \in [b/d]\) and \(y \in [a/d]\) such that \((ax + by) \bmod (ab/d) = d\). This is exactly what the Rust function in the beginning does.</p>
<h3>Finer points of the implementation</h3>
<p>Let \(a = bq + r\) with \(r \in [b]\), ie \(0 \le r &lt; b\). The key step is to find \(x\) and \(y\) given \(x'\) and \(y'\) with \(d \equiv bx' + ry' \pmod {br/d}\). Substituting,
\(bx' + ry' = bx' + (a-bq)y' = ay' + b(x' - qy').\)
So \(x = y'\) and \(y = (x' - qy') \bmod (a/d)\). I will leave it as an exerise for the reader to figure out why the arcane expression <code>(((b * x' + r - d) / r) * q + x' + a - q) % a</code> is equivalent to this (and is ensured to not underflow). Suggestions for simpler equivalent expressions are welcome.</p>
<p>The recursive call can be avoided by reworking the above inductive step &quot;outside-in&quot; instead of &quot;inside-out&quot;. I have not checked what expressions you get but I would guess it involves more magic.</p>
<h3>The divisors of \(0\)</h3>
<p>Let's say \(a = 0\) and \(b &gt; 0\). Then \(d = \gcd(a, b) = b\), \(a/d = 0\), \(b/d = 1\) and \(ab/d = 0\). So we want to find \(x \in [1]\) and \(y\) representing a coset of \(0\mathbf{Z}\), ie \(y \in \mathbf{Z}\) such that \(d \equiv ax + by \pmod{0}\), ie \(d = by\). So it's reasonable to say that the output here should be \(x = 0\) and \(y = 1\). The implementation above handles only this case and not the symmetric case \(a &gt; 0\), \(b = 0\) but it would be easy to modify it to do so.</p>
<p>What about \(a = b = 0\)? Now \(d\) should be \(0\), so \(a/d\), \(b/d\) and \(ab/d\) don't make sense. Going back to the the original definition, any \(x\) and \(y\) satisfy \(ax + by = d\), so \(x\) and \(y\) are well-defined as elements of \(\mathbf{Z}/\mathbf{Z}\), so by our convention we should take \(x = y = 0\). This is probably the most sensible answer in this case, but that's not saying much.</p>

        </div>
    </div>
</body>

</html>